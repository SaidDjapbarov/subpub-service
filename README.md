# subpub-service

**subpub-service** — лёгкий gRPC-сервис на Go. С помощью него можно подписываться на ключ и рассылать подписчикам события в порядке очереди. В основе сервиса лежит шина subpub.

Сервис предоставляет два gRPC-метода:

- **Publish** — публикует строковое событие для ключа, который задан;  
- **Subscribe** — открывает стрим и доставляет клиенту все события по ключу в порядке очереди.  

В решении применены такие паттерны микросервисов на Go:  
**dependency injection** для передачи зависимостей и **graceful shutdown** для правильной остановки сервиса.

Для большей ясности я старался комментировать код.

---

## Обзор

Вкратце, как устроен и работает сервис:

1. **Инициализация**  
   - Читается конфигурация из `config.yaml` (порт gRPC, таймаут shutdown, тип логов).  
   - Создаётся логгер на базе `log/slog`.  
   - Инициализируется шина `subpub.NewSubPub()`.  

2. **gRPC-сервер**  
   - Регистрируется сервис `PubSub` (схема описана в `proto/subpub.proto`).  
   - Два метода:  
     - `Publish(key, data)` — кладёт событие в шину.  
     - `Subscribe(key)` —  открывает подписку: все события по ключу приходят клиенту в порядке FIFO.  
   - Включена поддержка Reflection для удобства работы через `grpcurl`.  

3. **Dependency Injection**  
   - В `main.go` зависимости (шина и логгер) передаются в конструктор сервера `app.NewServer(bus, log)`.  

4. **Graceful shutdown**  
   - При получении SIGINT/SIGTERM сервер перестаёт принимать новые RPC (`grpcServer.GracefulStop()`).  
   - Затем вызывается `bus.Close(ctx)` с таймаутом, чтобы все опубликованные до этого вызова сообщения были доставлены подписчикам.  

5. **Поток данных**  
   - Клиент выполняет `Subscribe`, получает поток `Event{data}`.  
   - Любой клиент может вызвать `Publish`, и данные будут разосланы всем активным подписчикам того же ключа.  
   - FIFO достигается за счёт упорядоченной отправки в буферизированные каналы каждого подписчика.  

---

## Паттерны и подходы

В этом разделе кратко описаны основные приёмы и архитектурные решения, использованные в сервисе.

### Dependency Injection  

Я использовал «constructor injection»:  
1. В `main.go` создаём все зависимости (шина `subpub.NewSubPub()`, логер из `logger.New()`).  
2. Передаём их в конструктор gRPC-сервера:
   
   ```go
   server := app.NewServer(bus, log)
   pb.RegisterPubSubServer(grpcSrv, server)
   ```
   
Это позволяет подменить зависимости в тестах и сразу видеть, откуда они приходят.

### Graceful shutdown

Для корректного завершения работы сервиса:
1. Ловим системные сигналы SIGINT/SIGTERM.
2. Вызываем grpcServer.GracefulStop() — сервис перестаёт принимать новые соединения и ждёт завершения текущих.
3. Затем bus.Close(ctx) с таймаутом из конфига — шина успевает доставить все уже опубликованные сообщения.
4. Только после этого процесс полностью завершается.

### Конфигурация через YAML

Пакет internal/config загружает config.yaml и заполняет структуру:

```yaml
grpc_port: ":50051"
shutdown_timeout: 5s
log_level: "info"
```

Это позволяет без перекомпиляции менять порт, таймаут или тип логов.

### Логирование

Использован log/slog, обёрнутый в internal/logger.
- Управление типом вывода (debug, info, warn, error) через конфиг.

### gRPC Reflection

Для удобства использования grpcurl и любых динамических клиентов я регистрировал Reflection API:

```go
reflection.Register(grpcSrv)
```

Это избавляет от необходимости всегда передавать .proto при тестировании и ускоряет отладку.

### Организация кода

Разделение на каталоги:
- subpub/ — первая часть задачи: шина событий с unit-тестами.
- proto/ — определение gRPC API и сгенерированный код.
- internal/config, internal/logger, internal/app — пакеты с бизнес-логикой.
- cmd/server — точка входа, инициализация зависимостей и правильное завершение работы.

---

## Требования

1. У меня версия Go **1.23.5**.
   Если у вас версия ниже, то необходимо будет в go.mod изменить версию на вашу, а также обновить версию Go в Dockerfile.
   Далее выполните в терминале go mod tidy, чтобы зависимости пришли в нужный порядок.

2. **grpcurl**. Для ручного тестирования сервиса я использовал **grpcurl**.
   Установить его можно таким образом:
   
   ```bash
   go install github.com/fullstorydev/grpcurl/cmd/grpcurl@latest
   ```
   
   Бинарник будет находиться тут — $(go env GOPATH)/bin
   Чтобы был доступен из любого терминала, добавим в PATH:
   
   ```bash
   echo 'export PATH="$PATH:$(go env GOPATH)/bin"' >> ~/.bashrc
   source ~/.bashrc
   ```
   
   Проверьте установку:
   
   ```bash
   grpcurl --help
   ```

3. **Docker (опицонально)**.
   
   Для сборки и запуска контейнера через docker build, docker run.
   Если его нет, то можно будет через go run запустить сервер.

---

## Установка и сборка

1. **Клонируйте репозиторий**:

   ```bash
   git clone https://github.com/SaidDjapbarov/subpub-service.git
   cd subpub-service
   ```

2. **Адаптируйте Go-версию**
   см. пункт 1 в "Требования".

3. **Соберите бинарный файл**:

   ```bash
   go build -o subpub-service ./cmd/server
   ```

   Появится исполняемый файл `subpub-service` в корне проекта.

---

## Конфигурация

Сервис читает файл `config.yaml` из рабочей директории. Если файл не найден или невалиден, приложение завершится с паникой.

Пример `config.yaml`:

```yaml
grpc_port: ":50051"
shutdown_timeout: 5s
log_level: "info"
````

**Пояснения полей:**

- `grpc_port`
  Порт и адрес, по которому запускается gRPC-сервер.
  Менять можно без перекомпиляции — просто измените значение в файле.

- `shutdown_timeout`
  Время, которое сервис будет ждать завершения обработки в двух этапах:
  
  1. `grpcServer.GracefulStop()` дожидается окончания активных RPC.
  2. `bus.Close(ctx)` дожидается доставки всех опубликованных сообщений.

  Если таймаут истечёт, оставшиеся горутины будут принудительно остановлены.

- `log_level`
  Типы подробности логов:

  - `debug` — все сообщения, включая внутренние события;
  - `info` — базовые события запуска/остановки и публикации;
  - `warn` — только предупреждения и ошибки;
  - `error` — только ошибки.

---

## Запуск сервиса

Сервис можно запустить двумя способами: локально и в Docker-контейнере.

### Локальный запуск

1. Убедитесь, что config.yaml настроен.
2. Запустите команду:
   
   ```bash
   go run ./cmd/server
   ````

   или

   ```bash
   ./subpub-service # если в "Установке и сборке" в собирали банарный файл
   ````
   В выводе вы увидите примерно:

   ```
   time=... level=INFO msg="gRPC сервер запущен" addr=:50051
   ```

3. Сервис готов обрабатывать запросы (Publish и Subscribe).

### Запуск через Docker

1. Соберите образ (из корня проекта):
   (в Dockerfile и в go.mod у вас обязательно должны совпадать версии Go с той, что у вас установлена,
   иначе будет ошибка)

   ```bash
   docker build -t subpub-service .
   ```
   
3. Запустите контейнер, открыв порт из конфига наружу:

   ```bash
   docker run -p 50051:50051 subpub-service
   ```
   
4. В логах контейнера должно появиться сообщение о старте:

   ```
   time=... level=INFO msg="gRPC сервер запущен" addr=:50051
   ```

---

## Unit-тесты шины

  В каталоге `subpub/` лежат unit-тесты, которые проверяют работу шины:

- **TestFIFO**: доставка сообщений в порядке публикации (FIFO).  
- **TestSlowSubscriberDoesNotBlockFast**: медленный подписчик не задерживает быстрых.  
- **TestUnsubscribe**: после `Unsubscribe()` уведомления больше не приходят.  
- **TestClose_WaitsForDelivery**: `Close(ctx)` ждёт доставки уже опубликованных сообщений.  
- **TestClose_CancelContext**: `Close(ctx)` немедленно прерывается при отменённом контексте.  
- **TestGoroutineLeak**: проверка отсутствия утечек горутин после `Close`.

  Чтобы запустить эти тесты, выполните из корня проекта:

  - Запуск основных юнит-тестов шины
  
  ```bash
  go test ./subpub
  ```

  - Проверка покрытия
  
  ```bash
  go test -cover ./subpub
  ```

---

## Тесты через `grpcurl` (с Reflection)

Ниже я описал тесты сервиса. Во многих случаях в одном терминале нужно открыть стрим `Subscribe`, а в другом выполнить `Publish`.
И, конечно, у вас должен быть запущен сам сервис (см. предыдущий пункт)

#### Тест 1. Простой сценарий

1. **Терминал A (подписчик):**

   ```bash
   grpcurl -plaintext -d '{"key":"news"}' localhost:50051 pb.PubSub/Subscribe
   ```

   — команда зависнет, ожидая события.

2. **Терминал B (публикация):**

   ```bash
   grpcurl -plaintext -d '{"key":"news","data":"privet"}' localhost:50051 pb.PubSub/Publish
   ```

- **Ожидаемый вывод в Терминале A:**

  ```
  {
    "data": "hello"
  }

  ```

#### Тест 2. Несколько подписчиков

1. Откройте два терминала A и B, в каждом выполните:

   ```bash
   grpcurl -plaintext -d '{"key":"chat"}' localhost:50051 pb.PubSub/Subscribe
   ```
2. В третьем терминале C опубликуйте:

   ```bash
   grpcurl -plaintext -d '{"key":"chat","data":"privet"}' localhost:50051 pb.PubSub/Publish
   ```

- **Ожидаемый вывод**

  В обоих терминалах A и B появится:

  ```
  {
  "data": "privet"
  }
  ```

#### Тест 3. Публикация без подписчиков

- ```bash
  grpcurl -plaintext -d '{"key":"no-subs","data":"x"}' localhost:50051 pb.PubSub/Publish
  ```

- **Ожидаемый вывод:**

  ```json
  {}
  ```
  — сервис не падает, просто возвращает пустой ответ.

#### Тест 4. FIFO-порядок

1. Подпишитесь в терминале A:

   ```bash
   grpcurl -plaintext -d '{"key":"fifo"}' localhost:50051 pb.PubSub/Subscribe
   ```
2. Отправьте в терминале B:

   ```bash
   grpcurl -plaintext -d '{"key":"fifo","data":"1"}' localhost:50051 pb.PubSub/Publish
   grpcurl -plaintext -d '{"key":"fifo","data":"2"}' localhost:50051 pb.PubSub/Publish
   grpcurl -plaintext -d '{"key":"fifo","data":"3"}' localhost:50051 pb.PubSub/Publish
   ```

- **Ожидаемый вывод:**
 
  ```
  {
    "data": "1"
  }
  {
    "data": "2"
  }
  {
    "data": "3"
  }  
  ```

#### Тест 5. Graceful shutdown

1. Откройте подписчика:

   ```bash
   grpcurl -plaintext -d '{"key":"stop"}' localhost:50051 pb.PubSub/Subscribe
   ```
   
2. В другом терминале отправьте SIGINT сервису (`Ctrl+C` в терминале, где он запущен).
3. После остановки сервера попробуйте опубликовать:

   ```bash
   grpcurl -plaintext -d '{"key":"stop","data":"x"}' localhost:50051 pb.PubSub/Publish
   ```

- **Ожидаемый результат:**
  
  Подписчик закроет стрим.
  Публикация вернёт ошибку:

  ```
  ERROR:
    Code: Unavailable
    Message: error reading from server: EOF
  ```




